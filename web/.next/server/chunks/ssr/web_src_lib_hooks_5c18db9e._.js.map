{"version":3,"sources":["../../../../../web/src/lib/hooks/useDebounce.tsx","../../../../../web/src/lib/hooks/useTheme.ts","../../../../../web/src/lib/hooks/index.ts","../../../../../web/src/lib/hooks/useAnalyticsData.ts","../../../../../web/src/lib/hooks/useChartData.ts","../../../../../web/src/lib/hooks/useRealtimeEvents.ts","../../../../../web/src/lib/hooks/useOptimisticState.ts","../../../../../web/src/lib/hooks/useErrorRecovery.ts"],"sourcesContent":["import { useState, useEffect } from 'react';\n\n/**\n * Debounce hook - delays updating value until user stops typing\n * @param value - The value to debounce\n * @param delay - Delay in milliseconds (default: 300ms)\n * @returns Debounced value\n */\nexport function useDebounce<T>(value: T, delay: number = 300): T {\n  const [debouncedValue, setDebouncedValue] = useState<T>(value);\n\n  useEffect(() => {\n    // Set timeout to update debounced value after delay\n    const handler = setTimeout(() => {\n      setDebouncedValue(value);\n    }, delay);\n\n    // Cleanup timeout if value changes before delay completes\n    return () => {\n      clearTimeout(handler);\n    };\n  }, [value, delay]);\n\n  return debouncedValue;\n}\n","'use client';\n\nexport { useTheme } from '@/components/providers/ThemeProvider';\n","// Export all custom hooks for easy importing\n\n// Core hooks\nexport { useAuth } from './useAuth';\nexport { useSocket } from './useSocket';\nexport { useToast } from './useToast';\nexport { useTheme } from './useTheme';\nexport { useDebounce } from './useDebounce';\n\n// Analytics and data hooks\nexport { useAnalyticsData } from './useAnalyticsData';\nexport { useChartData } from './useChartData';\n\n// Real-time and state management hooks (Phase 8 - Socket.io integration)\nexport { useRealtimeEvents } from './useRealtimeEvents';\nexport type {\n  DeviceStatusUpdate,\n  PlaylistUpdate,\n  HealthAlert,\n  ScheduleExecution,\n  UseRealtimeEventsOptions,\n} from './useRealtimeEvents';\n\nexport { useOptimisticState } from './useOptimisticState';\nexport type { OptimisticUpdate, UseOptimisticStateOptions } from './useOptimisticState';\n\nexport { useErrorRecovery } from './useErrorRecovery';\nexport type {\n  ErrorSeverity,\n  RetryConfig,\n  CircuitBreakerConfig,\n  ErrorInfo,\n  UseErrorRecoveryOptions,\n} from './useErrorRecovery';\n","'use client';\n\nimport { useState, useEffect, useCallback } from 'react';\nimport { apiClient } from '@/lib/api';\n\ntype DateRange = 'week' | 'month' | 'year';\n\n/**\n * Device Metrics Hook - Real API Integration\n * Fetches device uptime/status metrics over time\n */\nexport function useDeviceMetrics(dateRange: DateRange = 'month') {\n  const [data, setData] = useState<any[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        setError(null);\n\n        // Map date range to days\n        const daysMap: Record<DateRange, number> = {\n          week: 7,\n          month: 30,\n          year: 365,\n        };\n        const days = daysMap[dateRange];\n\n        // Try to fetch from API\n        try {\n          const response = await apiClient.getDeviceMetrics?.(dateRange);\n          if (response && response.length > 0) {\n            setData(response);\n            return;\n          }\n        } catch (apiError) {\n          // Fall through to mock data if API not available\n          console.log('Analytics API not available, using mock data');\n        }\n\n        // Generate mock data if API unavailable\n        const mockData = Array.from({ length: days }, (_, i) => ({\n          date: new Date(Date.now() - (days - 1 - i) * 24 * 60 * 60 * 1000).toLocaleDateString(\n            'en-US',\n            { month: 'short', day: 'numeric' }\n          ),\n          mobile: 85 + Math.random() * 10,\n          tablet: 92 + Math.random() * 8,\n          desktop: 98 + Math.random() * 2,\n        }));\n\n        setData(mockData);\n      } catch (err) {\n        setError(err instanceof Error ? err.message : 'Failed to fetch device metrics');\n        setData([]);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n  }, [dateRange]);\n\n  return { data, loading, error, dateRange };\n}\n\n/**\n * Content Performance Hook - Real API Integration\n */\nexport function useContentPerformance(dateRange: DateRange = 'month') {\n  const [data, setData] = useState<any[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        setError(null);\n\n        // Try to fetch from API\n        try {\n          const response = await apiClient.getContentPerformance?.(dateRange);\n          if (response && response.length > 0) {\n            setData(response);\n            return;\n          }\n        } catch (apiError) {\n          console.log('Content performance API not available, using mock data');\n        }\n\n        // Mock data fallback\n        const mockData = [\n          { title: 'Welcome Video', views: 1240, engagement: 87, shares: 45 },\n          { title: 'Product Demo', views: 980, engagement: 76, shares: 32 },\n          { title: 'Tutorial Series', views: 2100, engagement: 92, shares: 58 },\n          { title: 'Company Overview', views: 650, engagement: 64, shares: 18 },\n          { title: 'Customer Testimonials', views: 1580, engagement: 89, shares: 42 },\n          { title: 'FAQ Section', views: 420, engagement: 45, shares: 12 },\n        ];\n\n        setData(mockData);\n      } catch (err) {\n        setError(err instanceof Error ? err.message : 'Failed to fetch content performance');\n        setData([]);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n  }, [dateRange]);\n\n  return { data, loading, error, dateRange };\n}\n\n/**\n * Usage Trends Hook - Real API Integration\n */\nexport function useUsageTrends(dateRange: DateRange = 'month') {\n  const [data, setData] = useState<any[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        setError(null);\n\n        const daysMap: Record<DateRange, number> = {\n          week: 7,\n          month: 30,\n          year: 365,\n        };\n        const days = daysMap[dateRange];\n\n        // Try to fetch from API\n        try {\n          const response = await apiClient.getUsageTrends?.(dateRange);\n          if (response && response.length > 0) {\n            setData(response);\n            return;\n          }\n        } catch (apiError) {\n          console.log('Usage trends API not available, using mock data');\n        }\n\n        // Mock data fallback\n        const mockData = Array.from({ length: days }, (_, i) => ({\n          date: new Date(Date.now() - (days - 1 - i) * 24 * 60 * 60 * 1000).toLocaleDateString(\n            'en-US',\n            { month: 'short', day: 'numeric' }\n          ),\n          video: 2400 + Math.random() * 800,\n          image: 1200 + Math.random() * 400,\n          text: 600 + Math.random() * 300,\n          interactive: 800 + Math.random() * 400,\n        }));\n\n        setData(mockData);\n      } catch (err) {\n        setError(err instanceof Error ? err.message : 'Failed to fetch usage trends');\n        setData([]);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n  }, [dateRange]);\n\n  return { data, loading, error, dateRange };\n}\n\n/**\n * Device Distribution Hook - Real API Integration\n */\nexport function useDeviceDistribution() {\n  const [data, setData] = useState<any[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        setError(null);\n\n        // Try to fetch from API\n        try {\n          const response = await apiClient.getDeviceDistribution?.();\n          if (response && response.length > 0) {\n            setData(response);\n            return;\n          }\n        } catch (apiError) {\n          console.log('Device distribution API not available, using mock data');\n        }\n\n        // Mock data fallback\n        const mockData = [\n          { name: 'Smartphones', value: 35, color: '#3B82F6' },\n          { name: 'Tablets', value: 25, color: '#8B5CF6' },\n          { name: 'Desktop Displays', value: 28, color: '#EC4899' },\n          { name: 'Smart TVs', value: 8, color: '#F59E0B' },\n          { name: 'Interactive Kiosks', value: 4, color: '#10B981' },\n        ];\n\n        setData(mockData);\n      } catch (err) {\n        setError(err instanceof Error ? err.message : 'Failed to fetch device distribution');\n        setData([]);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n  }, []);\n\n  return { data, loading, error };\n}\n\n/**\n * Bandwidth Usage Hook - Real API Integration\n */\nexport function useBandwidthUsage(dateRange: DateRange = 'month') {\n  const [data, setData] = useState<any[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        setError(null);\n\n        const daysMap: Record<DateRange, number> = {\n          week: 7,\n          month: 30,\n          year: 365,\n        };\n        const days = daysMap[dateRange];\n\n        // Try to fetch from API\n        try {\n          const response = await apiClient.getBandwidthUsage?.(dateRange);\n          if (response && response.length > 0) {\n            setData(response);\n            return;\n          }\n        } catch (apiError) {\n          console.log('Bandwidth usage API not available, using mock data');\n        }\n\n        // Mock data fallback\n        const mockData = Array.from({ length: days }, (_, i) => ({\n          date: new Date(Date.now() - (days - 1 - i) * 24 * 60 * 60 * 1000).toLocaleDateString(\n            'en-US',\n            { month: 'short', day: 'numeric' }\n          ),\n          current: 2400 + Math.random() * 1000,\n          average: 2200,\n          peak: 3200,\n        }));\n\n        setData(mockData);\n      } catch (err) {\n        setError(err instanceof Error ? err.message : 'Failed to fetch bandwidth usage');\n        setData([]);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n  }, [dateRange]);\n\n  return { data, loading, error, dateRange };\n}\n\n/**\n * Playlist Performance Hook - Real API Integration\n */\nexport function usePlaylistPerformance(dateRange: DateRange = 'month') {\n  const [data, setData] = useState<any[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        setError(null);\n\n        // Try to fetch from API\n        try {\n          const response = await apiClient.getPlaylistPerformance?.(dateRange);\n          if (response && response.length > 0) {\n            setData(response);\n            return;\n          }\n        } catch (apiError) {\n          console.log('Playlist performance API not available, using mock data');\n        }\n\n        // Mock data fallback\n        const mockData = [\n          { name: 'Morning Promotions', plays: 234, engagement: 87, uniqueDevices: 12 },\n          { name: 'Lunch Specials', plays: 189, engagement: 92, uniqueDevices: 10 },\n          { name: 'Evening Content', plays: 156, engagement: 78, uniqueDevices: 8 },\n          { name: 'Educational Videos', plays: 298, engagement: 85, uniqueDevices: 15 },\n          { name: 'Emergency Alerts', plays: 45, engagement: 95, uniqueDevices: 5 },\n        ];\n\n        setData(mockData);\n      } catch (err) {\n        setError(err instanceof Error ? err.message : 'Failed to fetch playlist performance');\n        setData([]);\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n  }, [dateRange]);\n\n  return { data, loading, error, dateRange };\n}\n","'use client';\n\nimport { useState, useEffect } from 'react';\n\n/**\n * Device Metrics Hook\n * Returns device uptime/status over time\n */\nexport function useDeviceMetrics() {\n  const [data, setData] = useState<any[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        // In production, fetch from real API\n        // For now, generate mock data\n        const mockData = Array.from({ length: 30 }, (_, i) => ({\n          date: new Date(Date.now() - (29 - i) * 24 * 60 * 60 * 1000)\n            .toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),\n          mobile: 85 + Math.random() * 10,\n          tablet: 92 + Math.random() * 8,\n          desktop: 98 + Math.random() * 2,\n        }));\n        setData(mockData);\n        setError(null);\n      } catch (err) {\n        setError(err instanceof Error ? err.message : 'Failed to fetch device metrics');\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n  }, []);\n\n  return { data, loading, error };\n}\n\n/**\n * Content Performance Hook\n * Returns content views and engagement metrics\n */\nexport function useContentPerformance() {\n  const [data, setData] = useState<any[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        const mockData = [\n          { title: 'Welcome Video', views: 1240, engagement: 87, shares: 45 },\n          { title: 'Product Demo', views: 980, engagement: 76, shares: 32 },\n          { title: 'Tutorial Series', views: 2100, engagement: 92, shares: 58 },\n          { title: 'Company Overview', views: 650, engagement: 64, shares: 18 },\n          { title: 'Customer Testimonials', views: 1580, engagement: 89, shares: 42 },\n          { title: 'FAQ Section', views: 420, engagement: 45, shares: 12 },\n        ];\n        setData(mockData);\n        setError(null);\n      } catch (err) {\n        setError(err instanceof Error ? err.message : 'Failed to fetch content performance');\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n  }, []);\n\n  return { data, loading, error };\n}\n\n/**\n * Usage Trends Hook\n * Returns overall usage patterns by content type\n */\nexport function useUsageTrends() {\n  const [data, setData] = useState<any[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        const mockData = Array.from({ length: 30 }, (_, i) => ({\n          date: new Date(Date.now() - (29 - i) * 24 * 60 * 60 * 1000)\n            .toLocaleDateString('en-US', { month: 'short', day: 'numeric' }),\n          video: 2400 + Math.random() * 800,\n          image: 1200 + Math.random() * 400,\n          text: 600 + Math.random() * 300,\n          interactive: 800 + Math.random() * 400,\n        }));\n        setData(mockData);\n        setError(null);\n      } catch (err) {\n        setError(err instanceof Error ? err.message : 'Failed to fetch usage trends');\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n  }, []);\n\n  return { data, loading, error };\n}\n\n/**\n * Device Distribution Hook\n * Returns device type breakdown\n */\nexport function useDeviceDistribution() {\n  const [data, setData] = useState<any[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        const mockData = [\n          { name: 'Mobile Displays', value: 35, count: 128 },\n          { name: 'Tablets', value: 25, count: 92 },\n          { name: 'Desktop Screens', value: 20, count: 73 },\n          { name: 'Smart TVs', value: 15, count: 55 },\n          { name: 'Kiosks', value: 5, count: 18 },\n        ];\n        setData(mockData);\n        setError(null);\n      } catch (err) {\n        setError(err instanceof Error ? err.message : 'Failed to fetch device distribution');\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n  }, []);\n\n  return { data, loading, error };\n}\n\n/**\n * Bandwidth Usage Hook\n * Returns network usage over time\n */\nexport function useBandwidthUsage() {\n  const [data, setData] = useState<any[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        const mockData = Array.from({ length: 24 }, (_, i) => {\n          const hour = String(i).padStart(2, '0');\n          return {\n            time: `${hour}:00`,\n            current: 45 + Math.random() * 50,\n            average: 42,\n            peak: 85,\n          };\n        });\n        setData(mockData);\n        setError(null);\n      } catch (err) {\n        setError(err instanceof Error ? err.message : 'Failed to fetch bandwidth usage');\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n  }, []);\n\n  return { data, loading, error };\n}\n\n/**\n * Playlist Performance Hook\n * Returns top playlists by engagement\n */\nexport function usePlaylistPerformance() {\n  const [data, setData] = useState<any[]>([]);\n  const [loading, setLoading] = useState(true);\n  const [error, setError] = useState<string | null>(null);\n\n  useEffect(() => {\n    const fetchData = async () => {\n      try {\n        setLoading(true);\n        const mockData = [\n          { name: 'Morning Briefing', views: 3200, avgWatchTime: 12, completion: 78 },\n          { name: 'Product Launch', views: 2800, avgWatchTime: 15, completion: 85 },\n          { name: 'Weekly Updates', views: 2400, avgWatchTime: 10, completion: 72 },\n          { name: 'Training Series', views: 1900, avgWatchTime: 25, completion: 65 },\n          { name: 'Event Coverage', views: 1200, avgWatchTime: 8, completion: 55 },\n        ];\n        setData(mockData);\n        setError(null);\n      } catch (err) {\n        setError(err instanceof Error ? err.message : 'Failed to fetch playlist performance');\n      } finally {\n        setLoading(false);\n      }\n    };\n\n    fetchData();\n  }, []);\n\n  return { data, loading, error };\n}\n","// Real-time Event Handlers for Vizora\n// Manages Socket.io events with advanced state synchronization, optimistic updates, and error recovery\n\nimport { useEffect, useCallback, useRef, useState } from 'react';\nimport { useSocket } from './useSocket';\nimport type { Display, Content, Playlist, Schedule } from '../types';\n\n// Event types\nexport type DeviceStatusUpdate = {\n  deviceId: string;\n  status: 'online' | 'offline';\n  lastSeen: string;\n  currentPlaylistId?: string;\n};\n\nexport type PlaylistUpdate = {\n  playlistId: string;\n  action: 'created' | 'updated' | 'deleted' | 'items_reordered';\n  payload: Partial<Playlist>;\n};\n\nexport type HealthAlert = {\n  deviceId: string;\n  alertType: 'high_cpu' | 'high_memory' | 'disk_full' | 'offline' | 'error';\n  severity: 'critical' | 'warning' | 'info';\n  message: string;\n  timestamp: string;\n};\n\nexport type ScheduleExecution = {\n  scheduleId: string;\n  displayId: string;\n  playlistId: string;\n  action: 'started' | 'completed' | 'failed';\n  timestamp: string;\n  error?: string;\n};\n\n// Sync Queue for offline support\ninterface SyncQueueItem {\n  id: string;\n  event: string;\n  data: any;\n  timestamp: number;\n  retryCount: number;\n}\n\n// State synchronization with conflict resolution\ninterface SyncState {\n  lastSyncTime: number;\n  pendingChanges: Map<string, any>;\n  conflictedChanges: Map<string, any>;\n}\n\nexport interface UseRealtimeEventsOptions {\n  enabled?: boolean;\n  onDeviceStatusChange?: (update: DeviceStatusUpdate) => void;\n  onPlaylistChange?: (update: PlaylistUpdate) => void;\n  onHealthAlert?: (alert: HealthAlert) => void;\n  onScheduleExecution?: (execution: ScheduleExecution) => void;\n  onConnectionChange?: (isConnected: boolean) => void;\n  onSyncStateChange?: (state: SyncState) => void;\n  offlineQueueSize?: number;\n  retryAttempts?: number;\n}\n\nexport function useRealtimeEvents(options: UseRealtimeEventsOptions = {}) {\n  const {\n    enabled = true,\n    onDeviceStatusChange,\n    onPlaylistChange,\n    onHealthAlert,\n    onScheduleExecution,\n    onConnectionChange,\n    onSyncStateChange,\n    offlineQueueSize = 50,\n    retryAttempts = 3,\n  } = options;\n\n  const { socket, isConnected, on } = useSocket();\n  const [isOffline, setIsOffline] = useState(false);\n  const [syncState, setSyncState] = useState<SyncState>({\n    lastSyncTime: Date.now(),\n    pendingChanges: new Map(),\n    conflictedChanges: new Map(),\n  });\n\n  // Offline sync queue\n  const syncQueueRef = useRef<SyncQueueItem[]>([]);\n  const offlineQueueRef = useRef<SyncQueueItem[]>([]);\n\n  // Emit event with optimistic update support\n  const emitEvent = useCallback(\n    (event: string, data: any, options?: { optimistic?: boolean; onRollback?: () => void }) => {\n      if (!socket) return;\n\n      const eventId = `${event}_${Date.now()}_${Math.random()}`;\n\n      // Add to pending changes if optimistic\n      if (options?.optimistic) {\n        setSyncState((prev) => ({\n          ...prev,\n          pendingChanges: new Map(prev.pendingChanges).set(eventId, { event, data }),\n        }));\n      }\n\n      // Emit through socket or add to offline queue\n      if (isConnected && socket) {\n        socket.emit(event, { ...data, eventId });\n      } else {\n        // Add to offline queue\n        const queueItem: SyncQueueItem = {\n          id: eventId,\n          event,\n          data: { ...data, eventId },\n          timestamp: Date.now(),\n          retryCount: 0,\n        };\n\n        offlineQueueRef.current.push(queueItem);\n\n        // Respect queue size limit\n        if (offlineQueueRef.current.length > offlineQueueSize) {\n          offlineQueueRef.current.shift();\n        }\n\n        console.log('[RealtimeEvents] Event queued offline:', event, queueItem);\n      }\n    },\n    [socket, isConnected, offlineQueueSize]\n  );\n\n  // Conflict resolution for state synchronization\n  const resolveConflict = useCallback(\n    (localChange: any, remoteChange: any): any => {\n      // Strategy: Remote wins (server is source of truth)\n      // But merge if they affect different fields\n      if (\n        typeof localChange === 'object' &&\n        typeof remoteChange === 'object' &&\n        !Array.isArray(localChange)\n      ) {\n        return {\n          ...localChange,\n          ...remoteChange,\n          // Keep local timestamp for optimistic updates\n          _localTimestamp: localChange._localTimestamp,\n          _remoteTimestamp: remoteChange._remoteTimestamp,\n        };\n      }\n      return remoteChange;\n    },\n    []\n  );\n\n  // Sync offline queue when reconnected\n  const syncOfflineQueue = useCallback(async () => {\n    if (!isConnected || !socket) return;\n\n    const itemsToSync = [...offlineQueueRef.current];\n    console.log('[RealtimeEvents] Syncing offline queue, items:', itemsToSync.length);\n\n    for (const item of itemsToSync) {\n      if (item.retryCount >= retryAttempts) {\n        console.warn('[RealtimeEvents] Max retries exceeded for:', item.event, item.id);\n        // Move to conflicted changes for manual resolution\n        setSyncState((prev) => ({\n          ...prev,\n          conflictedChanges: new Map(prev.conflictedChanges).set(item.id, item),\n        }));\n        continue;\n      }\n\n      try {\n        socket.emit(item.event, item.data);\n        item.retryCount++;\n\n        // Remove from queue after successful emit\n        offlineQueueRef.current = offlineQueueRef.current.filter((qi) => qi.id !== item.id);\n        console.log('[RealtimeEvents] Successfully synced:', item.event);\n      } catch (error) {\n        console.error('[RealtimeEvents] Failed to sync event:', error);\n        item.retryCount++;\n      }\n    }\n\n    // Update sync state\n    setSyncState((prev) => ({\n      ...prev,\n      lastSyncTime: Date.now(),\n    }));\n  }, [isConnected, socket, retryAttempts]);\n\n  // Device status update handler\n  const handleDeviceStatusUpdate = useCallback(\n    (update: DeviceStatusUpdate) => {\n      console.log('[RealtimeEvents] Device status update:', update);\n      onDeviceStatusChange?.(update);\n\n      // Remove from pending changes if this was an optimistic update\n      setSyncState((prev) => ({\n        ...prev,\n        pendingChanges: new Map(\n          [...prev.pendingChanges].filter(([_, val]) => val.deviceId !== update.deviceId)\n        ),\n      }));\n    },\n    [onDeviceStatusChange]\n  );\n\n  // Playlist update handler with conflict resolution\n  const handlePlaylistUpdate = useCallback(\n    (update: PlaylistUpdate) => {\n      console.log('[RealtimeEvents] Playlist update:', update);\n      onPlaylistChange?.(update);\n\n      // Check for conflicts with pending changes\n      setSyncState((prev) => {\n        const conflicted = [...prev.pendingChanges.entries()].filter(\n          ([_, val]) => val.playlistId === update.playlistId\n        );\n\n        if (conflicted.length > 0) {\n          const resolved = resolveConflict(conflicted[0][1], update.payload);\n          return {\n            ...prev,\n            pendingChanges: new Map(\n              [...prev.pendingChanges].filter(([id]) => !conflicted.some(([cId]) => cId === id))\n            ),\n          };\n        }\n\n        return prev;\n      });\n    },\n    [onPlaylistChange, resolveConflict]\n  );\n\n  // Health alert handler\n  const handleHealthAlert = useCallback(\n    (alert: HealthAlert) => {\n      console.log('[RealtimeEvents] Health alert:', alert);\n      onHealthAlert?.(alert);\n    },\n    [onHealthAlert]\n  );\n\n  // Schedule execution handler\n  const handleScheduleExecution = useCallback(\n    (execution: ScheduleExecution) => {\n      console.log('[RealtimeEvents] Schedule execution:', execution);\n      onScheduleExecution?.(execution);\n    },\n    [onScheduleExecution]\n  );\n\n  // Setup Socket.io event listeners\n  useEffect(() => {\n    if (!enabled || !socket) return;\n\n    // Device status updates\n    const unsubDeviceStatus = on('device:status-update', handleDeviceStatusUpdate);\n\n    // Playlist changes\n    const unsubPlaylist = on('playlist:updated', handlePlaylistUpdate);\n\n    // Health alerts\n    const unsubHealth = on('health:alert', handleHealthAlert);\n\n    // Schedule execution\n    const unsubSchedule = on('schedule:executed', handleScheduleExecution);\n\n    // Connection state change\n    const unsubConnect = on('connect', () => {\n      setIsOffline(false);\n      onConnectionChange?.(true);\n      console.log('[RealtimeEvents] Connected, syncing offline queue...');\n      syncOfflineQueue();\n    });\n\n    const unsubDisconnect = on('disconnect', () => {\n      setIsOffline(true);\n      onConnectionChange?.(false);\n      console.log('[RealtimeEvents] Disconnected, offline mode enabled');\n    });\n\n    // Sync state update callback\n    if (onSyncStateChange) {\n      onSyncStateChange(syncState);\n    }\n\n    return () => {\n      unsubDeviceStatus?.();\n      unsubPlaylist?.();\n      unsubHealth?.();\n      unsubSchedule?.();\n      unsubConnect?.();\n      unsubDisconnect?.();\n    };\n  }, [\n    enabled,\n    socket,\n    on,\n    handleDeviceStatusUpdate,\n    handlePlaylistUpdate,\n    handleHealthAlert,\n    handleScheduleExecution,\n    onConnectionChange,\n    onSyncStateChange,\n    syncState,\n    syncOfflineQueue,\n  ]);\n\n  // Monitor offline/online status\n  useEffect(() => {\n    const handleOnline = () => {\n      console.log('[RealtimeEvents] Browser online, attempting to sync...');\n      setIsOffline(false);\n      if (isConnected) {\n        syncOfflineQueue();\n      }\n    };\n\n    const handleOffline = () => {\n      console.log('[RealtimeEvents] Browser offline, queuing events...');\n      setIsOffline(true);\n    };\n\n    window.addEventListener('online', handleOnline);\n    window.addEventListener('offline', handleOffline);\n\n    return () => {\n      window.removeEventListener('online', handleOnline);\n      window.removeEventListener('offline', handleOffline);\n    };\n  }, [isConnected, syncOfflineQueue]);\n\n  // Public API\n  return {\n    // State\n    isConnected,\n    isOffline,\n    syncState,\n    offlineQueueLength: offlineQueueRef.current.length,\n\n    // Methods\n    emitDeviceUpdate: (data: DeviceStatusUpdate) => {\n      emitEvent('device:update', data, { optimistic: true });\n    },\n    emitPlaylistUpdate: (data: PlaylistUpdate) => {\n      emitEvent('playlist:update', data, { optimistic: true });\n    },\n    emitScheduleUpdate: (data: ScheduleExecution) => {\n      emitEvent('schedule:update', data, { optimistic: true });\n    },\n    emitCustomEvent: (event: string, data: any, options?: { optimistic?: boolean }) => {\n      emitEvent(event, data, options);\n    },\n\n    // Sync management\n    syncOfflineQueue,\n    clearOfflineQueue: () => {\n      console.log('[RealtimeEvents] Clearing offline queue');\n      offlineQueueRef.current = [];\n    },\n    getOfflineQueue: () => [...offlineQueueRef.current],\n    getConflictedChanges: () => new Map(syncState.conflictedChanges),\n    resolveConflict,\n  };\n}\n","// Optimistic State Management with Rollback Support\n// Handles optimistic UI updates with automatic rollback on failure\n\nimport { useState, useCallback, useRef } from 'react';\n\nexport interface OptimisticUpdate<T> {\n  id: string;\n  previousState: T;\n  optimisticState: T;\n  timestamp: number;\n  metadata?: Record<string, any>;\n}\n\nexport interface UseOptimisticStateOptions {\n  onRollback?: (update: OptimisticUpdate<any>) => void;\n  onCommit?: (update: OptimisticUpdate<any>) => void;\n  enableLogging?: boolean;\n}\n\nexport function useOptimisticState<T>(\n  initialState: T,\n  options: UseOptimisticStateOptions = {}\n) {\n  const { onRollback, onCommit, enableLogging = true } = options;\n\n  const [state, setState] = useState<T>(initialState);\n  const [pendingUpdates, setPendingUpdates] = useState<Map<string, OptimisticUpdate<T>>>(\n    new Map()\n  );\n  const updateQueueRef = useRef<OptimisticUpdate<T>[]>([]);\n\n  // Apply optimistic update\n  const updateOptimistic = useCallback(\n    (id: string, updater: (prev: T) => T, metadata?: Record<string, any>) => {\n      setState((prevState) => {\n        const optimisticState = updater(prevState);\n\n        // Track the update\n        const update: OptimisticUpdate<T> = {\n          id,\n          previousState: prevState,\n          optimisticState,\n          timestamp: Date.now(),\n          metadata,\n        };\n\n        setPendingUpdates((prev) => new Map(prev).set(id, update));\n        updateQueueRef.current.push(update);\n\n        if (enableLogging) {\n          console.log('[OptimisticState] Applied optimistic update:', id, {\n            previous: prevState,\n            optimistic: optimisticState,\n          });\n        }\n\n        return optimisticState;\n      });\n    },\n    [enableLogging]\n  );\n\n  // Commit optimistic update (confirm with server)\n  const commitOptimistic = useCallback((id: string) => {\n    setPendingUpdates((prev) => {\n      const updated = new Map(prev);\n      const update = updated.get(id);\n\n      if (update) {\n        if (enableLogging) {\n          console.log('[OptimisticState] Committed update:', id);\n        }\n        onCommit?.(update);\n        updated.delete(id);\n      }\n\n      return updated;\n    });\n  }, [enableLogging, onCommit]);\n\n  // Rollback optimistic update on failure\n  const rollbackOptimistic = useCallback(\n    (id: string, fallbackState?: T) => {\n      setPendingUpdates((prev) => {\n        const updated = new Map(prev);\n        const update = updated.get(id);\n\n        if (update) {\n          setState(fallbackState ?? update.previousState);\n\n          if (enableLogging) {\n            console.log('[OptimisticState] Rolled back update:', id, {\n              previousState: update.previousState,\n            });\n          }\n\n          onRollback?.(update);\n          updated.delete(id);\n        }\n\n        return updated;\n      });\n    },\n    [enableLogging, onRollback]\n  );\n\n  // Rollback all pending updates\n  const rollbackAll = useCallback(() => {\n    setPendingUpdates((prev) => {\n      if (prev.size === 0) return prev;\n\n      // Get the first update to find the original state\n      const updates = Array.from(prev.values());\n      const originalState = updates[0]?.previousState;\n\n      if (originalState) {\n        setState(originalState);\n\n        if (enableLogging) {\n          console.log('[OptimisticState] Rolled back all updates:', prev.size);\n        }\n\n        updates.forEach((update) => onRollback?.(update));\n      }\n\n      return new Map();\n    });\n  }, [enableLogging, onRollback]);\n\n  // Batch optimistic updates\n  const batchUpdate = useCallback(\n    (updates: Array<{ id: string; updater: (prev: T) => T; metadata?: Record<string, any> }>) => {\n      setState((prevState) => {\n        let currentState = prevState;\n\n        updates.forEach(({ id, updater, metadata }) => {\n          currentState = updater(currentState);\n\n          const update: OptimisticUpdate<T> = {\n            id,\n            previousState: prevState,\n            optimisticState: currentState,\n            timestamp: Date.now(),\n            metadata,\n          };\n\n          setPendingUpdates((prev) => new Map(prev).set(id, update));\n          updateQueueRef.current.push(update);\n\n          if (enableLogging) {\n            console.log('[OptimisticState] Batched update:', id);\n          }\n        });\n\n        return currentState;\n      });\n    },\n    [enableLogging]\n  );\n\n  return {\n    state,\n    pendingUpdates,\n    updateOptimistic,\n    commitOptimistic,\n    rollbackOptimistic,\n    rollbackAll,\n    batchUpdate,\n    getPendingCount: () => pendingUpdates.size,\n    hasPendingUpdates: () => pendingUpdates.size > 0,\n    getUpdateQueue: () => [...updateQueueRef.current],\n  };\n}\n","// Advanced Error Recovery and Retry Logic\n// Handles exponential backoff, circuit breaker pattern, and intelligent retries\n\nimport { useCallback, useRef, useState } from 'react';\n\nexport type ErrorSeverity = 'critical' | 'warning' | 'info';\n\nexport interface RetryConfig {\n  maxAttempts: number;\n  initialDelay: number; // milliseconds\n  maxDelay: number; // milliseconds\n  backoffMultiplier: number; // exponential backoff factor\n  jitter: boolean; // add randomness to prevent thundering herd\n}\n\nexport interface CircuitBreakerConfig {\n  failureThreshold: number; // number of failures before opening circuit\n  successThreshold: number; // number of successes to close circuit\n  timeout: number; // milliseconds before attempting to half-open\n}\n\nexport interface ErrorInfo {\n  id: string;\n  error: Error | string;\n  severity: ErrorSeverity;\n  timestamp: number;\n  retryCount: number;\n  lastRetryTime?: number;\n  nextRetryTime?: number;\n  context?: Record<string, any>;\n}\n\nexport interface UseErrorRecoveryOptions {\n  onError?: (errorInfo: ErrorInfo) => void;\n  onRetry?: (errorInfo: ErrorInfo) => void;\n  onCircuitBreakerChange?: (isOpen: boolean) => void;\n  retryConfig?: Partial<RetryConfig>;\n  circuitBreakerConfig?: Partial<CircuitBreakerConfig>;\n  enableLogging?: boolean;\n}\n\n// Circuit Breaker States\ntype CircuitState = 'CLOSED' | 'OPEN' | 'HALF_OPEN';\n\ninterface CircuitBreaker {\n  state: CircuitState;\n  failureCount: number;\n  successCount: number;\n  lastFailureTime?: number;\n  lastStateChangeTime: number;\n}\n\nexport function useErrorRecovery(options: UseErrorRecoveryOptions = {}) {\n  const {\n    onError,\n    onRetry,\n    onCircuitBreakerChange,\n    retryConfig: customRetryConfig,\n    circuitBreakerConfig: customCircuitBreakerConfig,\n    enableLogging = true,\n  } = options;\n\n  // Default configs\n  const retryConfig: RetryConfig = {\n    maxAttempts: 3,\n    initialDelay: 1000,\n    maxDelay: 30000,\n    backoffMultiplier: 2,\n    jitter: true,\n    ...customRetryConfig,\n  };\n\n  const circuitBreakerConfig: CircuitBreakerConfig = {\n    failureThreshold: 5,\n    successThreshold: 2,\n    timeout: 60000,\n    ...customCircuitBreakerConfig,\n  };\n\n  // State\n  const [errors, setErrors] = useState<Map<string, ErrorInfo>>(new Map());\n  const [circuitBreaker, setCircuitBreaker] = useState<CircuitBreaker>({\n    state: 'CLOSED',\n    failureCount: 0,\n    successCount: 0,\n    lastStateChangeTime: Date.now(),\n  });\n\n  const retriesRef = useRef<Map<string, { count: number; timeout?: NodeJS.Timeout }>>(\n    new Map()\n  );\n\n  // Calculate retry delay with exponential backoff\n  const calculateDelay = useCallback(\n    (retryCount: number): number => {\n      const exponentialDelay = retryConfig.initialDelay * Math.pow(retryConfig.backoffMultiplier, retryCount);\n      const capped = Math.min(exponentialDelay, retryConfig.maxDelay);\n      const withJitter = retryConfig.jitter ? capped * (0.5 + Math.random()) : capped;\n\n      return Math.floor(withJitter);\n    },\n    [retryConfig]\n  );\n\n  // Update circuit breaker state\n  const updateCircuitBreakerState = useCallback(\n    (isSuccess: boolean) => {\n      setCircuitBreaker((prev) => {\n        let newState = prev.state;\n        let newFailureCount = prev.failureCount;\n        let newSuccessCount = prev.successCount;\n\n        if (isSuccess) {\n          newFailureCount = 0;\n          newSuccessCount = prev.successCount + 1;\n\n          if (prev.state === 'HALF_OPEN' && newSuccessCount >= circuitBreakerConfig.successThreshold) {\n            newState = 'CLOSED';\n            newSuccessCount = 0;\n\n            if (enableLogging) {\n              console.log('[ErrorRecovery] Circuit breaker CLOSED after successful recovery');\n            }\n            onCircuitBreakerChange?.(false);\n          }\n        } else {\n          newSuccessCount = 0;\n          newFailureCount = prev.failureCount + 1;\n\n          if (newFailureCount >= circuitBreakerConfig.failureThreshold && prev.state === 'CLOSED') {\n            newState = 'OPEN';\n\n            if (enableLogging) {\n              console.log('[ErrorRecovery] Circuit breaker OPENED due to repeated failures');\n            }\n            onCircuitBreakerChange?.(true);\n          }\n        }\n\n        return {\n          ...prev,\n          state: newState,\n          failureCount: newFailureCount,\n          successCount: newSuccessCount,\n          lastFailureTime: isSuccess ? prev.lastFailureTime : Date.now(),\n          lastStateChangeTime: newState !== prev.state ? Date.now() : prev.lastStateChangeTime,\n        };\n      });\n    },\n    [circuitBreakerConfig, enableLogging, onCircuitBreakerChange]\n  );\n\n  // Check if circuit breaker should transition from OPEN to HALF_OPEN\n  const checkCircuitBreakerTimeout = useCallback(() => {\n    setCircuitBreaker((prev) => {\n      if (prev.state === 'OPEN') {\n        const timeSinceStateChange = Date.now() - prev.lastStateChangeTime;\n        if (timeSinceStateChange >= circuitBreakerConfig.timeout) {\n          if (enableLogging) {\n            console.log('[ErrorRecovery] Circuit breaker transitioning to HALF_OPEN');\n          }\n          return {\n            ...prev,\n            state: 'HALF_OPEN',\n            successCount: 0,\n            failureCount: 0,\n            lastStateChangeTime: Date.now(),\n          };\n        }\n      }\n      return prev;\n    });\n  }, [circuitBreakerConfig.timeout, enableLogging]);\n\n  // Record error\n  const recordError = useCallback(\n    (id: string, error: Error | string, severity: ErrorSeverity = 'warning', context?: Record<string, any>) => {\n      const errorInfo: ErrorInfo = {\n        id,\n        error,\n        severity,\n        timestamp: Date.now(),\n        retryCount: 0,\n        context,\n      };\n\n      setErrors((prev) => new Map(prev).set(id, errorInfo));\n      updateCircuitBreakerState(false);\n      onError?.(errorInfo);\n\n      if (enableLogging) {\n        console.error('[ErrorRecovery] Error recorded:', {\n          id,\n          error: error instanceof Error ? error.message : error,\n          severity,\n        });\n      }\n    },\n    [updateCircuitBreakerState, onError, enableLogging]\n  );\n\n  // Retry with exponential backoff\n  const retry = useCallback(\n    (\n      id: string,\n      operation: () => Promise<any>,\n      onSuccess?: (result: any) => void,\n      onFailure?: (error: Error) => void\n    ) => {\n      checkCircuitBreakerTimeout();\n\n      // Reject if circuit breaker is open\n      if (circuitBreaker.state === 'OPEN') {\n        const error = new Error('Circuit breaker is OPEN - too many failures');\n        recordError(id, error, 'critical');\n        onFailure?.(error as Error);\n        return Promise.reject(error);\n      }\n\n      const executeRetry = (retryCount = 0) => {\n        if (retryCount >= retryConfig.maxAttempts) {\n          const error = new Error(`Max retry attempts (${retryConfig.maxAttempts}) exceeded for ${id}`);\n          recordError(id, error, 'critical', { retryCount });\n          onFailure?.(error as Error);\n          return Promise.reject(error);\n        }\n\n        return operation()\n          .then((result) => {\n            // Clear retry state\n            retriesRef.current.delete(id);\n            setErrors((prev) => {\n              const updated = new Map(prev);\n              updated.delete(id);\n              return updated;\n            });\n\n            // Update circuit breaker on success\n            updateCircuitBreakerState(true);\n            onSuccess?.(result);\n\n            if (enableLogging) {\n              console.log('[ErrorRecovery] Operation succeeded:', { id, retryCount });\n            }\n\n            return result;\n          })\n          .catch((error) => {\n            const delay = calculateDelay(retryCount);\n            const nextRetryTime = Date.now() + delay;\n\n            setErrors((prev) => {\n              const updated = new Map(prev);\n              const errorInfo = updated.get(id) ?? {\n                id,\n                error,\n                severity: 'warning' as const,\n                timestamp: Date.now(),\n                retryCount: 0,\n              };\n              errorInfo.retryCount = retryCount + 1;\n              errorInfo.lastRetryTime = Date.now();\n              errorInfo.nextRetryTime = nextRetryTime;\n              updated.set(id, errorInfo as ErrorInfo);\n              return updated;\n            });\n\n            onRetry?.({\n              id,\n              error,\n              severity: 'warning',\n              timestamp: Date.now(),\n              retryCount: retryCount + 1,\n              lastRetryTime: Date.now(),\n              nextRetryTime,\n            });\n\n            if (enableLogging) {\n              console.log('[ErrorRecovery] Retrying after', delay, 'ms:', {\n                id,\n                attempt: retryCount + 1,\n                maxAttempts: retryConfig.maxAttempts,\n              });\n            }\n\n            return new Promise((resolve, reject) => {\n              const timeout = setTimeout(\n                () => executeRetry(retryCount + 1).then(resolve).catch(reject),\n                delay\n              );\n\n              // Store timeout for cleanup\n              const retryState = retriesRef.current.get(id) ?? { count: 0 };\n              retryState.timeout = timeout;\n              retriesRef.current.set(id, retryState);\n            });\n          });\n      };\n\n      return executeRetry();\n    },\n    [\n      retryConfig,\n      circuitBreaker,\n      calculateDelay,\n      recordError,\n      updateCircuitBreakerState,\n      checkCircuitBreakerTimeout,\n      enableLogging,\n    ]\n  );\n\n  // Clear error\n  const clearError = useCallback((id: string) => {\n    setErrors((prev) => {\n      const updated = new Map(prev);\n      updated.delete(id);\n      return updated;\n    });\n\n    const retryState = retriesRef.current.get(id);\n    if (retryState?.timeout) {\n      clearTimeout(retryState.timeout);\n    }\n    retriesRef.current.delete(id);\n  }, []);\n\n  // Clear all errors\n  const clearAllErrors = useCallback(() => {\n    retriesRef.current.forEach(({ timeout }) => {\n      if (timeout) clearTimeout(timeout);\n    });\n    retriesRef.current.clear();\n    setErrors(new Map());\n  }, []);\n\n  // Reset circuit breaker\n  const resetCircuitBreaker = useCallback(() => {\n    setCircuitBreaker({\n      state: 'CLOSED',\n      failureCount: 0,\n      successCount: 0,\n      lastStateChangeTime: Date.now(),\n    });\n\n    if (enableLogging) {\n      console.log('[ErrorRecovery] Circuit breaker reset to CLOSED');\n    }\n\n    onCircuitBreakerChange?.(false);\n  }, [enableLogging, onCircuitBreakerChange]);\n\n  return {\n    // State\n    errors,\n    circuitBreaker,\n    isCircuitBreakerOpen: circuitBreaker.state === 'OPEN',\n\n    // Methods\n    recordError,\n    retry,\n    clearError,\n    clearAllErrors,\n    resetCircuitBreaker,\n\n    // Helpers\n    getError: (id: string) => errors.get(id),\n    getAllErrors: () => new Map(errors),\n    getErrorCount: () => errors.size,\n    hasCriticalErrors: () => Array.from(errors.values()).some((e) => e.severity === 'critical'),\n  };\n}\n"],"names":[],"mappings":"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"}