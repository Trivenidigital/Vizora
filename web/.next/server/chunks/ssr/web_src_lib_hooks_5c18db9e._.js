module.exports=[38982,a=>{"use strict";var b=a.i(872);function c(a,d=300){let[e,f]=(0,b.useState)(a);return(0,b.useEffect)(()=>{let b=setTimeout(()=>{f(a)},d);return()=>{clearTimeout(b)}},[a,d]),e}a.s(["useDebounce",()=>c])},1168,a=>{"use strict";a.i(20208),a.s([])},68997,90629,35660,59518,96336,a=>{"use strict";a.i(52336);var b=a.i(38438);a.i(57052),a.i(1168),a.i(38982);var c=a.i(872),d=a.i(79412);function e(a="month"){let[b,f]=(0,c.useState)([]),[g,h]=(0,c.useState)(!0),[i,j]=(0,c.useState)(null);return(0,c.useEffect)(()=>{(async()=>{try{h(!0),j(null);let b={week:7,month:30,year:365}[a];try{let b=await d.apiClient.getDeviceMetrics?.(a);if(b&&b.length>0)return void f(b)}catch(a){console.log("Analytics API not available, using mock data")}let c=Array.from({length:b},(a,c)=>({date:new Date(Date.now()-(b-1-c)*864e5).toLocaleDateString("en-US",{month:"short",day:"numeric"}),mobile:85+10*Math.random(),tablet:92+8*Math.random(),desktop:98+2*Math.random()}));f(c)}catch(a){j(a instanceof Error?a.message:"Failed to fetch device metrics"),f([])}finally{h(!1)}})()},[a]),{data:b,loading:g,error:i,dateRange:a}}function f(a="month"){let[b,e]=(0,c.useState)([]),[g,h]=(0,c.useState)(!0),[i,j]=(0,c.useState)(null);return(0,c.useEffect)(()=>{(async()=>{try{h(!0),j(null);try{let b=await d.apiClient.getContentPerformance?.(a);if(b&&b.length>0)return void e(b)}catch(a){console.log("Content performance API not available, using mock data")}e([{title:"Welcome Video",views:1240,engagement:87,shares:45},{title:"Product Demo",views:980,engagement:76,shares:32},{title:"Tutorial Series",views:2100,engagement:92,shares:58},{title:"Company Overview",views:650,engagement:64,shares:18},{title:"Customer Testimonials",views:1580,engagement:89,shares:42},{title:"FAQ Section",views:420,engagement:45,shares:12}])}catch(a){j(a instanceof Error?a.message:"Failed to fetch content performance"),e([])}finally{h(!1)}})()},[a]),{data:b,loading:g,error:i,dateRange:a}}function g(a="month"){let[b,e]=(0,c.useState)([]),[f,h]=(0,c.useState)(!0),[i,j]=(0,c.useState)(null);return(0,c.useEffect)(()=>{(async()=>{try{h(!0),j(null);let b={week:7,month:30,year:365}[a];try{let b=await d.apiClient.getUsageTrends?.(a);if(b&&b.length>0)return void e(b)}catch(a){console.log("Usage trends API not available, using mock data")}let c=Array.from({length:b},(a,c)=>({date:new Date(Date.now()-(b-1-c)*864e5).toLocaleDateString("en-US",{month:"short",day:"numeric"}),video:2400+800*Math.random(),image:1200+400*Math.random(),text:600+300*Math.random(),interactive:800+400*Math.random()}));e(c)}catch(a){j(a instanceof Error?a.message:"Failed to fetch usage trends"),e([])}finally{h(!1)}})()},[a]),{data:b,loading:f,error:i,dateRange:a}}function h(){let[a,b]=(0,c.useState)([]),[e,f]=(0,c.useState)(!0),[g,h]=(0,c.useState)(null);return(0,c.useEffect)(()=>{(async()=>{try{f(!0),h(null);try{let a=await d.apiClient.getDeviceDistribution?.();if(a&&a.length>0)return void b(a)}catch(a){console.log("Device distribution API not available, using mock data")}b([{name:"Smartphones",value:35,color:"#3B82F6"},{name:"Tablets",value:25,color:"#8B5CF6"},{name:"Desktop Displays",value:28,color:"#EC4899"},{name:"Smart TVs",value:8,color:"#F59E0B"},{name:"Interactive Kiosks",value:4,color:"#10B981"}])}catch(a){h(a instanceof Error?a.message:"Failed to fetch device distribution"),b([])}finally{f(!1)}})()},[]),{data:a,loading:e,error:g}}function i(a="month"){let[b,e]=(0,c.useState)([]),[f,g]=(0,c.useState)(!0),[h,j]=(0,c.useState)(null);return(0,c.useEffect)(()=>{(async()=>{try{g(!0),j(null);let b={week:7,month:30,year:365}[a];try{let b=await d.apiClient.getBandwidthUsage?.(a);if(b&&b.length>0)return void e(b)}catch(a){console.log("Bandwidth usage API not available, using mock data")}let c=Array.from({length:b},(a,c)=>({date:new Date(Date.now()-(b-1-c)*864e5).toLocaleDateString("en-US",{month:"short",day:"numeric"}),current:2400+1e3*Math.random(),average:2200,peak:3200}));e(c)}catch(a){j(a instanceof Error?a.message:"Failed to fetch bandwidth usage"),e([])}finally{g(!1)}})()},[a]),{data:b,loading:f,error:h,dateRange:a}}function j(a="month"){let[b,e]=(0,c.useState)([]),[f,g]=(0,c.useState)(!0),[h,i]=(0,c.useState)(null);return(0,c.useEffect)(()=>{(async()=>{try{g(!0),i(null);try{let b=await d.apiClient.getPlaylistPerformance?.(a);if(b&&b.length>0)return void e(b)}catch(a){console.log("Playlist performance API not available, using mock data")}e([{name:"Morning Promotions",plays:234,engagement:87,uniqueDevices:12},{name:"Lunch Specials",plays:189,engagement:92,uniqueDevices:10},{name:"Evening Content",plays:156,engagement:78,uniqueDevices:8},{name:"Educational Videos",plays:298,engagement:85,uniqueDevices:15},{name:"Emergency Alerts",plays:45,engagement:95,uniqueDevices:5}])}catch(a){i(a instanceof Error?a.message:"Failed to fetch playlist performance"),e([])}finally{g(!1)}})()},[a]),{data:b,loading:f,error:h,dateRange:a}}function k(a={}){let{enabled:d=!0,onDeviceStatusChange:e,onPlaylistChange:f,onHealthAlert:g,onScheduleExecution:h,onConnectionChange:i,onSyncStateChange:j,offlineQueueSize:l=50,retryAttempts:m=3}=a,{socket:n,isConnected:o,on:p}=(0,b.useSocket)(),[q,r]=(0,c.useState)(!1),[s,t]=(0,c.useState)({lastSyncTime:Date.now(),pendingChanges:new Map,conflictedChanges:new Map});(0,c.useRef)([]);let u=(0,c.useRef)([]),v=(0,c.useCallback)((a,b,c)=>{if(!n)return;let d=`${a}_${Date.now()}_${Math.random()}`;if(c?.optimistic&&t(c=>({...c,pendingChanges:new Map(c.pendingChanges).set(d,{event:a,data:b})})),o&&n)n.emit(a,{...b,eventId:d});else{let c={id:d,event:a,data:{...b,eventId:d},timestamp:Date.now(),retryCount:0};u.current.push(c),u.current.length>l&&u.current.shift(),console.log("[RealtimeEvents] Event queued offline:",a,c)}},[n,o,l]),w=(0,c.useCallback)((a,b)=>"object"!=typeof a||"object"!=typeof b||Array.isArray(a)?b:{...a,...b,_localTimestamp:a._localTimestamp,_remoteTimestamp:b._remoteTimestamp},[]),x=(0,c.useCallback)(async()=>{if(!o||!n)return;let a=[...u.current];for(let b of(console.log("[RealtimeEvents] Syncing offline queue, items:",a.length),a)){if(b.retryCount>=m){console.warn("[RealtimeEvents] Max retries exceeded for:",b.event,b.id),t(a=>({...a,conflictedChanges:new Map(a.conflictedChanges).set(b.id,b)}));continue}try{n.emit(b.event,b.data),b.retryCount++,u.current=u.current.filter(a=>a.id!==b.id),console.log("[RealtimeEvents] Successfully synced:",b.event)}catch(a){console.error("[RealtimeEvents] Failed to sync event:",a),b.retryCount++}}t(a=>({...a,lastSyncTime:Date.now()}))},[o,n,m]),y=(0,c.useCallback)(a=>{console.log("[RealtimeEvents] Device status update:",a),e?.(a),t(b=>({...b,pendingChanges:new Map([...b.pendingChanges].filter(([b,c])=>c.deviceId!==a.deviceId))}))},[e]),z=(0,c.useCallback)(a=>{console.log("[RealtimeEvents] Playlist update:",a),f?.(a),t(b=>{let c=[...b.pendingChanges.entries()].filter(([b,c])=>c.playlistId===a.playlistId);return c.length>0?(w(c[0][1],a.payload),{...b,pendingChanges:new Map([...b.pendingChanges].filter(([a])=>!c.some(([b])=>b===a)))}):b})},[f,w]),A=(0,c.useCallback)(a=>{console.log("[RealtimeEvents] Health alert:",a),g?.(a)},[g]),B=(0,c.useCallback)(a=>{console.log("[RealtimeEvents] Schedule execution:",a),h?.(a)},[h]);return(0,c.useEffect)(()=>{if(!d||!n)return;let a=p("device:status-update",y),b=p("playlist:updated",z),c=p("health:alert",A),e=p("schedule:executed",B),f=p("connect",()=>{r(!1),i?.(!0),console.log("[RealtimeEvents] Connected, syncing offline queue..."),x()}),g=p("disconnect",()=>{r(!0),i?.(!1),console.log("[RealtimeEvents] Disconnected, offline mode enabled")});return j&&j(s),()=>{a?.(),b?.(),c?.(),e?.(),f?.(),g?.()}},[d,n,p,y,z,A,B,i,j,s,x]),(0,c.useEffect)(()=>{let a=()=>{console.log("[RealtimeEvents] Browser online, attempting to sync..."),r(!1),o&&x()},b=()=>{console.log("[RealtimeEvents] Browser offline, queuing events..."),r(!0)};return window.addEventListener("online",a),window.addEventListener("offline",b),()=>{window.removeEventListener("online",a),window.removeEventListener("offline",b)}},[o,x]),{isConnected:o,isOffline:q,syncState:s,offlineQueueLength:u.current.length,emitDeviceUpdate:a=>{v("device:update",a,{optimistic:!0})},emitPlaylistUpdate:a=>{v("playlist:update",a,{optimistic:!0})},emitScheduleUpdate:a=>{v("schedule:update",a,{optimistic:!0})},emitCustomEvent:(a,b,c)=>{v(a,b,c)},syncOfflineQueue:x,clearOfflineQueue:()=>{console.log("[RealtimeEvents] Clearing offline queue"),u.current=[]},getOfflineQueue:()=>[...u.current],getConflictedChanges:()=>new Map(s.conflictedChanges),resolveConflict:w}}function l(a,b={}){let{onRollback:d,onCommit:e,enableLogging:f=!0}=b,[g,h]=(0,c.useState)(a),[i,j]=(0,c.useState)(new Map),k=(0,c.useRef)([]),m=(0,c.useCallback)((a,b,c)=>{h(d=>{let e=b(d),g={id:a,previousState:d,optimisticState:e,timestamp:Date.now(),metadata:c};return j(b=>new Map(b).set(a,g)),k.current.push(g),f&&console.log("[OptimisticState] Applied optimistic update:",a,{previous:d,optimistic:e}),e})},[f]),n=(0,c.useCallback)(a=>{j(b=>{let c=new Map(b),d=c.get(a);return d&&(f&&console.log("[OptimisticState] Committed update:",a),e?.(d),c.delete(a)),c})},[f,e]),o=(0,c.useCallback)((a,b)=>{j(c=>{let e=new Map(c),g=e.get(a);return g&&(h(b??g.previousState),f&&console.log("[OptimisticState] Rolled back update:",a,{previousState:g.previousState}),d?.(g),e.delete(a)),e})},[f,d]);return{state:g,pendingUpdates:i,updateOptimistic:m,commitOptimistic:n,rollbackOptimistic:o,rollbackAll:(0,c.useCallback)(()=>{j(a=>{if(0===a.size)return a;let b=Array.from(a.values()),c=b[0]?.previousState;return c&&(h(c),f&&console.log("[OptimisticState] Rolled back all updates:",a.size),b.forEach(a=>d?.(a))),new Map})},[f,d]),batchUpdate:(0,c.useCallback)(a=>{h(b=>{let c=b;return a.forEach(({id:a,updater:d,metadata:e})=>{let g={id:a,previousState:b,optimisticState:c=d(c),timestamp:Date.now(),metadata:e};j(b=>new Map(b).set(a,g)),k.current.push(g),f&&console.log("[OptimisticState] Batched update:",a)}),c})},[f]),getPendingCount:()=>i.size,hasPendingUpdates:()=>i.size>0,getUpdateQueue:()=>[...k.current]}}function m(a={}){let{onError:b,onRetry:d,onCircuitBreakerChange:e,retryConfig:f,circuitBreakerConfig:g,enableLogging:h=!0}=a,i={maxAttempts:3,initialDelay:1e3,maxDelay:3e4,backoffMultiplier:2,jitter:!0,...f},j={failureThreshold:5,successThreshold:2,timeout:6e4,...g},[k,l]=(0,c.useState)(new Map),[n,o]=(0,c.useState)({state:"CLOSED",failureCount:0,successCount:0,lastStateChangeTime:Date.now()}),p=(0,c.useRef)(new Map),q=(0,c.useCallback)(a=>{let b=Math.min(i.initialDelay*Math.pow(i.backoffMultiplier,a),i.maxDelay);return Math.floor(i.jitter?b*(.5+Math.random()):b)},[i]),r=(0,c.useCallback)(a=>{o(b=>{let c=b.state,d=b.failureCount,f=b.successCount;return a?(d=0,f=b.successCount+1,"HALF_OPEN"===b.state&&f>=j.successThreshold&&(c="CLOSED",f=0,h&&console.log("[ErrorRecovery] Circuit breaker CLOSED after successful recovery"),e?.(!1))):(f=0,(d=b.failureCount+1)>=j.failureThreshold&&"CLOSED"===b.state&&(c="OPEN",h&&console.log("[ErrorRecovery] Circuit breaker OPENED due to repeated failures"),e?.(!0))),{...b,state:c,failureCount:d,successCount:f,lastFailureTime:a?b.lastFailureTime:Date.now(),lastStateChangeTime:c!==b.state?Date.now():b.lastStateChangeTime}})},[j,h,e]),s=(0,c.useCallback)(()=>{o(a=>"OPEN"===a.state&&Date.now()-a.lastStateChangeTime>=j.timeout?(h&&console.log("[ErrorRecovery] Circuit breaker transitioning to HALF_OPEN"),{...a,state:"HALF_OPEN",successCount:0,failureCount:0,lastStateChangeTime:Date.now()}):a)},[j.timeout,h]),t=(0,c.useCallback)((a,c,d="warning",e)=>{let f={id:a,error:c,severity:d,timestamp:Date.now(),retryCount:0,context:e};l(b=>new Map(b).set(a,f)),r(!1),b?.(f),h&&console.error("[ErrorRecovery] Error recorded:",{id:a,error:c instanceof Error?c.message:c,severity:d})},[r,b,h]),u=(0,c.useCallback)((a,b,c,e)=>{if(s(),"OPEN"===n.state){let b=Error("Circuit breaker is OPEN - too many failures");return t(a,b,"critical"),e?.(b),Promise.reject(b)}let f=(g=0)=>{if(g>=i.maxAttempts){let b=Error(`Max retry attempts (${i.maxAttempts}) exceeded for ${a}`);return t(a,b,"critical",{retryCount:g}),e?.(b),Promise.reject(b)}return b().then(b=>(p.current.delete(a),l(b=>{let c=new Map(b);return c.delete(a),c}),r(!0),c?.(b),h&&console.log("[ErrorRecovery] Operation succeeded:",{id:a,retryCount:g}),b)).catch(b=>{let c=q(g),e=Date.now()+c;return l(c=>{let d=new Map(c),f=d.get(a)??{id:a,error:b,severity:"warning",timestamp:Date.now(),retryCount:0};return f.retryCount=g+1,f.lastRetryTime=Date.now(),f.nextRetryTime=e,d.set(a,f),d}),d?.({id:a,error:b,severity:"warning",timestamp:Date.now(),retryCount:g+1,lastRetryTime:Date.now(),nextRetryTime:e}),h&&console.log("[ErrorRecovery] Retrying after",c,"ms:",{id:a,attempt:g+1,maxAttempts:i.maxAttempts}),new Promise((b,d)=>{let e=setTimeout(()=>f(g+1).then(b).catch(d),c),h=p.current.get(a)??{count:0};h.timeout=e,p.current.set(a,h)})})};return f()},[i,n,q,t,r,s,h]),v=(0,c.useCallback)(a=>{l(b=>{let c=new Map(b);return c.delete(a),c});let b=p.current.get(a);b?.timeout&&clearTimeout(b.timeout),p.current.delete(a)},[]),w=(0,c.useCallback)(()=>{p.current.forEach(({timeout:a})=>{a&&clearTimeout(a)}),p.current.clear(),l(new Map)},[]),x=(0,c.useCallback)(()=>{o({state:"CLOSED",failureCount:0,successCount:0,lastStateChangeTime:Date.now()}),h&&console.log("[ErrorRecovery] Circuit breaker reset to CLOSED"),e?.(!1)},[h,e]);return{errors:k,circuitBreaker:n,isCircuitBreakerOpen:"OPEN"===n.state,recordError:t,retry:u,clearError:v,clearAllErrors:w,resetCircuitBreaker:x,getError:a=>k.get(a),getAllErrors:()=>new Map(k),getErrorCount:()=>k.size,hasCriticalErrors:()=>Array.from(k.values()).some(a=>"critical"===a.severity)}}a.s(["useBandwidthUsage",()=>i,"useContentPerformance",()=>f,"useDeviceDistribution",()=>h,"useDeviceMetrics",()=>e,"usePlaylistPerformance",()=>j,"useUsageTrends",()=>g],90629),a.s(["useRealtimeEvents",()=>k],35660),a.s(["useOptimisticState",()=>l],59518),a.s(["useErrorRecovery",()=>m],96336),a.s([],68997)}];

//# sourceMappingURL=web_src_lib_hooks_5c18db9e._.js.map